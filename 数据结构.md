## 1. 数组

影响数组性能的两个点

1. 数组扩容：数组扩容需要重新开辟内存空间，并把数据全部移动到新的内存中
2. 元素位移：以逆序方式插入，删除数据，其后的每一个数据都要向后位移

js中的数组可以自动扩容，比较方便

数组的插入和删除比较耗费性能，通过index访问和修改值不耗费性能

![image-20200923113420239](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200923113420239.png)

## 2. 栈

![image-20200923114726189](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200923114726189.png)

![image-20200923115726089](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200923115726089.png)







栈的应用：

1. 十进制转任意进制

   ```
   function convertion(num, scale = 10) {
     const stack = new Stack()
   
     let i = num
     for (; i > scale;) {
       stack.push(i % scale)
    i = (i - i % scale) / scale
     }
     stack.push(i)
     let res = ""
     for (let j = stack.size(); j > 0; j--) {
       res += stack.pop()
     }
     return res
   }
   
   
   //更好的实现
   function convertion(num, scale = 10) {
     const stack = new Stack()
     while (num > 0) {
       stack.push(num % scale)
       num = Math.floor(num / scale)
     }
     let res = ""
     while (!stack.isEmpty()) {
       res += stack.pop()
     }
     return res
   }
   ```
   
   

## 3. 队列

![image-20200923123116739](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200923123116739.png)

![image-20200923154905023](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200923154905023.png)

队列的数组实现：

```
function Queue(){
  this.items = []
}
Queue.prototype.enqueue = function (...arr){
  this.items.push(...arr);
}
Queue.prototype.dequeue = function (){
  //返回被删除的item
  return this.items.shift()
}
Queue.prototype.front = function (){
  reutrn this.items[0]
}
Queue.prototype.isEmpty = function (){
  return this.lenght===0
}
Queue.prototype.size = function (){
  return this.items.length
}
Queue.prototype.toString = function (){
  return 
}
```

### 3.1 实战：击鼓传花

![image-20200923162431049](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200923162431049.png)

```
const Queue = require('./Queue')
function game(arr, num) {
    let q = new Queue()
    arr.forEach(item => { q.enqueue(item) });
    //利用队列的进和出模拟一个环形结构
    while (q.size() > 1) {
        for (let i = 0; i < num - 1; i++) {
            //出队列又入队列，直到队列最前面的是这一轮要淘汰的item
            q.enqueue(q.dequeue())
        }
        q.dequeue()
    }
    return { name: q.front(), index: arr.indexOf(q.front) }
}

```

### 3.2 优先级队列

![image-20200923164935833](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200923164935833.png)

## 4. 链表

![image-20200924190748414](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200924190748414.png)

![image-20200924190904539](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200924190904539.png)

![image-20200924192133751](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200924192133751.png)

实现：

```

```

