## 1. 数组

影响数组性能的两个点

1. 数组扩容：数组扩容需要重新开辟内存空间，并把数据全部移动到新的内存中
2. 元素位移：以逆序方式插入，删除数据，其后的每一个数据都要向后位移

js中的数组可以自动扩容，比较方便

数组的插入和删除比较耗费性能，通过index访问和修改值不耗费性能

![image-20200923113420239](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200923113420239.png)

## 2. 栈

![image-20200923114726189](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200923114726189.png)

![image-20200923115726089](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200923115726089.png)







栈的应用：

1. 十进制转任意进制

   ```
   function convertion(num, scale = 10) {
     const stack = new Stack()
   
     let i = num
     for (; i > scale;) {
       stack.push(i % scale)
    i = (i - i % scale) / scale
     }
     stack.push(i)
     let res = ""
     for (let j = stack.size(); j > 0; j--) {
       res += stack.pop()
     }
     return res
   }
   
   
   //更好的实现
   function convertion(num, scale = 10) {
     const stack = new Stack()
     while (num > 0) {
       stack.push(num % scale)
       num = Math.floor(num / scale)
     }
     let res = ""
     while (!stack.isEmpty()) {
       res += stack.pop()
     }
     return res
   }
   ```
   
   

## 3. 队列

![image-20200923123116739](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200923123116739.png)

![image-20200923154905023](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200923154905023.png)

队列的数组实现：

```
function Queue(){
  this.items = []
}
Queue.prototype.enqueue = function (...arr){
  this.items.push(...arr);
}
Queue.prototype.dequeue = function (){
  //返回被删除的item
  return this.items.shift()
}
Queue.prototype.front = function (){
  reutrn this.items[0]
}
Queue.prototype.isEmpty = function (){
  return this.lenght===0
}
Queue.prototype.size = function (){
  return this.items.length
}
Queue.prototype.toString = function (){
  return 
}
```

### 3.1 实战：击鼓传花

![image-20200923162431049](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200923162431049.png)

```
// 利用队列出队入队的特性，把队列假想成一个圆环
// 当同一个元素出队后又入队的时候，圆环就闭合了
function game(nameList, num) {
    const queue = new Queue()
    nameList.forEach(item => queue.enqueue(item))
    let i = 0
    while (queue.size() > 1) {
        // 先出队
        const temp = queue.dequeue()
        i++
        //当i === num 不允许入队，该元素从队列中移除
        if (i === num) {
            i = 0
            continue
        } else {
            queue.enqueue(temp)
        }
    }
    return queue.front()
}
// 视频中的方法
function game(arr, num) {
    let q = new Queue()
    arr.forEach(item => { q.enqueue(item) });
    //利用队列的进和出模拟一个环形结构
    while (q.size() > 1) {
        for (let i = 0; i < num - 1; i++) {
            //出队列又入队列，直到队列最前面的是这一轮要淘汰的item
            q.enqueue(q.dequeue())
        }
        q.dequeue()
    }
    return { name: q.front(), index: arr.indexOf(q.front) }
}

```

### 3.2 优先级队列

优先级队列在元素入队的时候会考虑该元素的优先级，和其他的元素优先级进行比较，比较完成后得到一个正确的位置，其他方法和基本队列方法一样

![image-20200923164935833](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200923164935833.png)



## 4. 链表

![image-20200924190748414](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200924190748414.png)

![image-20200924190904539](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200924190904539.png)

![image-20200924192133751](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20200924192133751.png)



### 双向链表

![image-20210214201345497](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210214201345497.png)

![image-20210214201453682](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210214201453682.png)

![image-20210214202712736](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210214202712736.png)



## 5. 集合

![image-20210214220934834](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210214220934834.png)

无序（无法通过索引访问），不重复

![image-20210214221248159](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210214221248159.png)

![image-20210214222538195](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210214222538195.png)





## 6. 字典

![image-20210214230333169](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210214230333169.png)



![image-20210214230849535](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210214230849535.png)





## 7. 哈希表

![image-20210214231817806](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210214231817806.png)

![image-20210215122632088](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210215122632088.png)

为了把字符串转换为数组对应的下标，又不希望有字符串得到的下标是重复的，一般采用幂的连乘形式得到下标。但是这样得到的下标的范围会非常大，并且出现无用的下标，这时候就需要哈希化

![image-20210215122606456](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210215122606456.png)



![image-20210215123901238](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210215123901238.png)

### 哈希表的冲突

![image-20210215124410491](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210215124410491.png)

#### 链地址法解决冲突

![image-20210215124839391](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210215124839391.png)

![image-20210215125529158](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210215125529158.png)



#### 开放地址法解决冲突

![image-20210215125845115](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210215125845115.png)

 

![image-20210215130223931](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210215130223931.png)

数组是会随着开放因子扩容的，不会出现没有位置的情况

![image-20210215130531166](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210215130531166.png)

聚集的情况下，再次插入哈希化值相同的的数据，就要一直向后查询空位置，影响性能

![image-20210215131253389](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210215131253389.png)

![image-20210215132149985](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210215132149985.png)

根据哈希化之前的关键字的多少得到单独的不一样的步长

### 哈希化的效率

![image-20210215185003662](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210215185003662.png)

填装因子（负载系数）：loader factor

真实开发中，链地址法效率好于开放地址法



### 哈希函数

![image-20210218110420704](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210218110420704.png)

元素的均匀分布使得探测时间减少   

![image-20210218110917322](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210218110917322.png)

 ![image-20210218112143155](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210218112143155.png)

![image-20210218112310387](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210218112310387.png)

链地址法中长度为质数比开发地址法不重要

![image-20210218113503213](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210218113503213.png)

### 哈希表扩容（或缩小）

![image-20210218154518999](C:\Users\yyh\AppData\Roaming\Typora\typora-user-images\image-20210218154518999.png)





 

### 哈希表实现

#### 哈希函数实现

#### 链地址法哈希表

